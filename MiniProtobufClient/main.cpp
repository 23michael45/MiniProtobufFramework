#include <iostream>
#include "code/eventpp/callbacklist.h"
#include "code/eventpp/eventdispatcher.h"
#include "code/eventpp/eventqueue.h"

#include "code/protobuf/BaseCmd.pb.h"
#include <google/protobuf/descriptor.h>
#include <google/protobuf/message.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/io/zero_copy_stream_impl.h>
#include <algorithm>

#include "TcpClient.h"
using namespace std;
using namespace BaseCmd;
using namespace google;


void CallbackList()
{


	eventpp::CallbackList<void(const std::string &, const bool)> callbackList;

	callbackList.append([](const std::string & s, const bool b) {
		std::cout << std::boolalpha << "Got callback 1, s is " << s.c_str() << " b is " << b << std::endl;
	});
	callbackList.append([](std::string s, int b) {
		std::cout << std::boolalpha << "Got callback 2, s is " << s.c_str() << " b is " << b << std::endl;
	});
	callbackList("Hello world", true);

}


void EventDispatcher()
{
	eventpp::EventDispatcher<int, void()> dispatcher;
	dispatcher.appendListener(3, []() {
		std::cout << "Got event 3." << std::endl;
	});
	dispatcher.appendListener(5, []() {
		std::cout << "Got event 5." << std::endl;
	});
	dispatcher.appendListener(5, []() {
		std::cout << "Got another event 5." << std::endl;
	});
	// dispatch event 3
	dispatcher.dispatch(3);
	// dispatch event 5
	dispatcher.dispatch(5);
}
void func1(const std::string& s, const bool b) {
	std::cout << std::boolalpha << "Got event 3, s is " << s << " b is " << b << std::endl;
}

void EventQueue()
{
	eventpp::EventQueue<int, void(const std::string &, const bool)> queue;

	queue.appendListener(3, func1);
	queue.appendListener(5, [](const std::string& s, const bool b) {
		std::cout << std::boolalpha << "Got event 5, s is " << s << " b is " << b << std::endl;
	});

	// The listeners are not triggered during enqueue.
	queue.enqueue(3, "Hello", true);
	queue.enqueue(5, "World", false);

	// Process the event queue, dispatch all queued events.
	queue.process();
}

void bindfunc()
{
	using namespace std;
	auto fun = [](int *array, int n, int num) {
		for (int i = 0; i < n; i++)
		{
			if (array[i] > num)
				cout << array[i] << ends;
		}
		cout << endl;
	};
	int array[] = { 1, 3, 5, 7, 9 };
	//_1，_2 是占位符
	auto fun1 = bind(fun, std::placeholders::_1, std::placeholders::_2, 5);
	//等价于调用fun(array, sizeof(array) / sizeof(*array), 5);
	fun1(array, sizeof(array) / sizeof(*array));
	cin.get();
}

#define  MAX_BUFFER_SIZE 1024



void detectinput(shared_ptr<MessageRoute> spMessageRoute)
{
	//char temp = getchar();

	int random_number = 2 * rand() / double(RAND_MAX);
	std::vector<char> vec;
	vec.push_back('s');
	vec.push_back('m');
	vec.push_back('a');
	char temp = vec[random_number];

	if (temp == 's')
	{
		reqSignin req;
		sUser* user = req.add_user();
		user->set_name("michael");
		user->set_id(99);



		spMessageRoute->Send(req);
	}
	else if (temp == 'm')
	{
		reqMove req;
		req.set_forward(100);
		req.set_angle(200);


		spMessageRoute->Send(req);

	}
	else if (temp == 'a')
	{
		reqAlarm req;
		req.set_infomessage("Alerm message Info");


		spMessageRoute->Send(req);
	}

}

int clientStart()
{
	try
	{
		asio::io_context io_context;

		shared_ptr<MessageRoute> spMessageRoute(new MessageRoute());
		shared_ptr<TcpClient> spclient(new TcpClient(io_context, spMessageRoute));

		std::string ip = "127.0.0.1";
		std::string port = "88";
		spclient->Connect(ip, port);

		std::thread t([&io_context]() { io_context.run(); });


		while (true)
		{
			//io_context.run_one();
			detectinput(spMessageRoute);
		}

		spMessageRoute.reset();
		spclient.reset();
	}
	catch (std::exception& e)
	{
		std::cerr << e.what() << std::endl;
	}

	return 0;
}

#define  BUFF_SIZE  32
int main(int argc, char* argv[])
{


	//clientStart();
	
	string content = "This number is generated by an algorithm that returns a sequence of apparently non-related numbers each time it is called. This algorithm uses a seed to generate the series, which should be initialized to some distinctive value using function srand.";
	content += content;
	asio::streambuf sb;
	int size = 0;
	
	std::ostream os(&sb);

	size = sb.size();

	os.write(content.c_str(), content.length());

	size = sb.size();


	std::istream is(&sb);

	std::queue<char> dataqueue;
	std::istreambuf_iterator<char> isb(is), end;


	//while (isb != end)
	//{
	//	dataqueue.push(*isb++);

	//}

	size = dataqueue.size();


	asio::streambuf dataHolderBuf;
	//std::stringbuf dataHolderBuf;



	std::ostream oshold(&dataHolderBuf);
	auto oos = new google::protobuf::io::OstreamOutputStream(&oshold);
	auto cos = new google::protobuf::io::CodedOutputStream(oos);
	

	char buf[BUFF_SIZE];
	
	while (sb.size()> 0)
	{
		int readSize = std::min((int)(sb.size()), (int)BUFF_SIZE);
		is.read(buf, readSize);

		/*for (int i = 0 ; i< readSize;++i)
		{
			dataqueue.push(buf[i]);

		}*/
		cos->WriteRaw(buf, readSize);
		oshold.flush();
	}

	delete cos;
	delete oos;


	std::istream ishold(&dataHolderBuf);
	auto iis = new google::protobuf::io::IstreamInputStream(&ishold,sizeof(int));
	auto cis = new google::protobuf::io::CodedInputStream(iis);

	google::protobuf::uint32 readInt = 0;
	cis->ReadVarint32(&readInt);



	size = dataHolderBuf.size();

	//cis->ReadVarint32(&readInt);

	size = dataHolderBuf.size();


	delete cis;
	delete iis;



	iis = new google::protobuf::io::IstreamInputStream(&ishold, sizeof(int));
	cis = new google::protobuf::io::CodedInputStream(iis);


	google::protobuf::uint32 readInt2;
	cis->ReadVarint32(&readInt2);



	size = dataHolderBuf.size();

	cis->ReadVarint32(&readInt2);

	size = dataHolderBuf.size();


	delete cis;
	delete iis;
}


