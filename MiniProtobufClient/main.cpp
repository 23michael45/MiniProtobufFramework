#include <iostream>
#include "code/eventpp/callbacklist.h"
#include "code/eventpp/eventdispatcher.h"
#include "code/eventpp/eventqueue.h"

#include "code/protobuf/BaseCmd.pb.h"
#include <google/protobuf/descriptor.h>
#include <google/protobuf/message.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/io/zero_copy_stream_impl.h>
#include <algorithm>

#include "TcpClient.h"
using namespace std;
using namespace BaseCmd;
using namespace google;

#define  BUFF_SIZE  32

void CallbackList()
{


	eventpp::CallbackList<void(const std::string &, const bool)> callbackList;

	callbackList.append([](const std::string & s, const bool b) {
		std::cout << std::boolalpha << "Got callback 1, s is " << s.c_str() << " b is " << b << std::endl;
	});
	callbackList.append([](std::string s, int b) {
		std::cout << std::boolalpha << "Got callback 2, s is " << s.c_str() << " b is " << b << std::endl;
	});
	callbackList("Hello world", true);

}


void EventDispatcher()
{
	eventpp::EventDispatcher<int, void()> dispatcher;
	dispatcher.appendListener(3, []() {
		std::cout << "Got event 3." << std::endl;
	});
	dispatcher.appendListener(5, []() {
		std::cout << "Got event 5." << std::endl;
	});
	dispatcher.appendListener(5, []() {
		std::cout << "Got another event 5." << std::endl;
	});
	// dispatch event 3
	dispatcher.dispatch(3);
	// dispatch event 5
	dispatcher.dispatch(5);
}
void func1(const std::string& s, const bool b) {
	std::cout << std::boolalpha << "Got event 3, s is " << s << " b is " << b << std::endl;
}

void EventQueue()
{
	eventpp::EventQueue<int, void(const std::string &, const bool)> queue;

	queue.appendListener(3, func1);
	queue.appendListener(5, [](const std::string& s, const bool b) {
		std::cout << std::boolalpha << "Got event 5, s is " << s << " b is " << b << std::endl;
	});

	// The listeners are not triggered during enqueue.
	queue.enqueue(3, "Hello", true);
	queue.enqueue(5, "World", false);

	// Process the event queue, dispatch all queued events.
	queue.process();
}

void bindfunc()
{
	using namespace std;
	auto fun = [](int *array, int n, int num) {
		for (int i = 0; i < n; i++)
		{
			if (array[i] > num)
				cout << array[i] << ends;
		}
		cout << endl;
	};
	int array[] = { 1, 3, 5, 7, 9 };
	//_1，_2 是占位符
	auto fun1 = bind(fun, std::placeholders::_1, std::placeholders::_2, 5);
	//等价于调用fun(array, sizeof(array) / sizeof(*array), 5);
	fun1(array, sizeof(array) / sizeof(*array));
	cin.get();
}

#define  MAX_BUFFER_SIZE 1024



void detectinput(shared_ptr<MessageRoute> spMessageRoute)
{
	//char temp = getchar();

	int random_number = 3 * (rand()-1) / double(RAND_MAX);
	std::vector<char> vec;
	vec.push_back('s');
	vec.push_back('m');
	vec.push_back('a');
	char temp = vec[random_number];

	if (temp == 's')
	{
		reqSignin req;
		sUser* user = req.add_user();
		user->set_name("michael");
		user->set_id(99);

		int len = req.ByteSize();

		spMessageRoute->Send(req);
	}
	else if (temp == 'm')
	{
		reqMove req;
		req.set_forward(100);
		req.set_angle(200);

		int len = req.ByteSize();

		spMessageRoute->Send(req);

	}
	else if (temp == 'a')
	{
		reqAlarm req;
		req.set_infomessage("Alerm message Info");

		int len = req.ByteSize();

		spMessageRoute->Send(req);
	}

}

int clientStart()
{
	try
	{
		asio::io_context io_context;

		shared_ptr<MessageRoute> spMessageRoute(new MessageRoute());
		shared_ptr<TcpClient> spclient(new TcpClient(io_context, spMessageRoute));

		std::string ip = "127.0.0.1";
		std::string port = "88";
		spclient->Connect(ip, port);

		std::thread t([&io_context]() { io_context.run(); });


		int cur = 0;
		int num = 10001;
		while (++cur < num)
		{
			//io_context.run_one();
			detectinput(spMessageRoute);
		}
		t.join();
		spMessageRoute.reset();
		spclient.reset();
	}
	catch (std::exception& e)
	{
		std::cerr << e.what() << std::endl;
	}

	return 0;
}

template <class T>
void endswap(T *objp)
{
	unsigned char *memp = reinterpret_cast<unsigned char*>(objp);
	std::reverse(memp, memp + sizeof(T));
}


void streamReadWrite()
{

	string content = "This number is generated by an algorithm that returns a sequence of apparently non-related numbers each time it is called. This algorithm uses a seed to generate the series, which should be initialized to some distinctive value using function srand.";
	content += content;
	asio::streambuf sb;
	int size = 0;

	std::ostream os(&sb);

	size = sb.size();

	os.write(content.c_str(), content.length());

	size = sb.size();


	std::istream is(&sb);

	std::queue<char> dataqueue;
	std::istreambuf_iterator<char> isb(is), end;


	//while (isb != end)
	//{
	//	dataqueue.push(*isb++);

	//}

	size = dataqueue.size();


	asio::streambuf dataHolderBuf;
	//std::stringbuf dataHolderBuf;



	std::ostream oshold(&dataHolderBuf);
	auto oos = new google::protobuf::io::OstreamOutputStream(&oshold);
	auto cos = new google::protobuf::io::CodedOutputStream(oos);


	char buf[BUFF_SIZE];

	cos->WriteLittleEndian32(0x000000ff);
	cos->WriteLittleEndian32(0xff000000);



	delete cos;
	delete oos;

	oos = new google::protobuf::io::OstreamOutputStream(&oshold);
	cos = new google::protobuf::io::CodedOutputStream(oos);



	cos->WriteLittleEndian32(123);
	cos->WriteLittleEndian32(456);



	delete cos;
	delete oos;

	while (sb.size()> 0)
	{
		int readSize = std::min((int)(sb.size()), (int)BUFF_SIZE);
		is.read(buf, readSize);

		/*for (int i = 0 ; i< readSize;++i)
		{
		dataqueue.push(buf[i]);

		}*/
		cos->WriteRaw(buf, readSize);
		oshold.flush();
	}



	std::istream ishold(&dataHolderBuf);
	auto iis = new google::protobuf::io::IstreamInputStream(&ishold, sizeof(int) * 4);
	auto cis = new google::protobuf::io::CodedInputStream(iis);

	google::protobuf::uint32 readInt = 0;
	cis->ReadLittleEndian32(&readInt);

	//endswap(&readInt);

	cis->ReadLittleEndian32(&readInt);
	cis->ReadLittleEndian32(&readInt);
	cis->ReadLittleEndian32(&readInt);

	//endswap(&readInt);


	size = dataHolderBuf.size();

	//cis->ReadVarint32(&readInt);

	size = dataHolderBuf.size();


	delete cis;
	delete iis;



	iis = new google::protobuf::io::IstreamInputStream(&ishold, sizeof(int));
	cis = new google::protobuf::io::CodedInputStream(iis);


	google::protobuf::uint32 readInt2;
	cis->ReadVarint32(&readInt2);



	size = dataHolderBuf.size();

	cis->ReadVarint32(&readInt2);

	size = dataHolderBuf.size();


	delete cis;
	delete iis;
}




class Test
{
public:
	Test(string s)
	{
		str = s;
		cout << "Test creat\n";
	}
	~Test()
	{
		cout << "Test delete:" << str << endl;
	}
	string& getStr()
	{
		return str;
	}
	void setStr(string s)
	{
		str = s;
	}
	void print()
	{
		cout << str << endl;
	}
private:
	string str;
};



std::map<int, shared_ptr<Test>*> ptrmap;
int shared_ptr_test()
{
	shared_ptr<Test> ptest(new Test("123"));
	ptest->setStr("hello ");
	ptest->print();
	ptest.get()->print();
	ptest->getStr() += "world !";
	(*ptest).print();
	ptest.reset(new Test("123"));
	ptest->print();



	auto p = new shared_ptr<Test>(new Test("1235"));
	p->get()->print();

	ptrmap[0] = p;
	return 0;
}


int main(int argc, char* argv[])
{
	//shared_ptr_test();

	//ptrmap.erase(0);
	//delete ptrmap[0];

	/*ptrmap[0]->reset();*/


	asio::detail::thread_group    threads;

	//for (int i = 0 ; i< 1 ;i++)
	//{
	//	threads.create_thread([]() { int i = 0; });
	//}

	//threads.join();

	return clientStart();

}


