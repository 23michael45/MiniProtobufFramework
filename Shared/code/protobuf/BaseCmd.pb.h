// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: BaseCmd.proto

#ifndef PROTOBUF_INCLUDED_BaseCmd_2eproto
#define PROTOBUF_INCLUDED_BaseCmd_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_BaseCmd_2eproto 

namespace protobuf_BaseCmd_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[10];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_BaseCmd_2eproto
namespace BaseCmd {
class CmdType;
class CmdTypeDefaultTypeInternal;
extern CmdTypeDefaultTypeInternal _CmdType_default_instance_;
class notifyConnectionStatus;
class notifyConnectionStatusDefaultTypeInternal;
extern notifyConnectionStatusDefaultTypeInternal _notifyConnectionStatus_default_instance_;
class reqAlarm;
class reqAlarmDefaultTypeInternal;
extern reqAlarmDefaultTypeInternal _reqAlarm_default_instance_;
class reqMove;
class reqMoveDefaultTypeInternal;
extern reqMoveDefaultTypeInternal _reqMove_default_instance_;
class reqSignin;
class reqSigninDefaultTypeInternal;
extern reqSigninDefaultTypeInternal _reqSignin_default_instance_;
class rspAlarm;
class rspAlarmDefaultTypeInternal;
extern rspAlarmDefaultTypeInternal _rspAlarm_default_instance_;
class rspMove;
class rspMoveDefaultTypeInternal;
extern rspMoveDefaultTypeInternal _rspMove_default_instance_;
class rspSignin;
class rspSigninDefaultTypeInternal;
extern rspSigninDefaultTypeInternal _rspSignin_default_instance_;
class sUser;
class sUserDefaultTypeInternal;
extern sUserDefaultTypeInternal _sUser_default_instance_;
class sUser_ePhoneNumber;
class sUser_ePhoneNumberDefaultTypeInternal;
extern sUser_ePhoneNumberDefaultTypeInternal _sUser_ePhoneNumber_default_instance_;
}  // namespace BaseCmd
namespace google {
namespace protobuf {
template<> ::BaseCmd::CmdType* Arena::CreateMaybeMessage<::BaseCmd::CmdType>(Arena*);
template<> ::BaseCmd::notifyConnectionStatus* Arena::CreateMaybeMessage<::BaseCmd::notifyConnectionStatus>(Arena*);
template<> ::BaseCmd::reqAlarm* Arena::CreateMaybeMessage<::BaseCmd::reqAlarm>(Arena*);
template<> ::BaseCmd::reqMove* Arena::CreateMaybeMessage<::BaseCmd::reqMove>(Arena*);
template<> ::BaseCmd::reqSignin* Arena::CreateMaybeMessage<::BaseCmd::reqSignin>(Arena*);
template<> ::BaseCmd::rspAlarm* Arena::CreateMaybeMessage<::BaseCmd::rspAlarm>(Arena*);
template<> ::BaseCmd::rspMove* Arena::CreateMaybeMessage<::BaseCmd::rspMove>(Arena*);
template<> ::BaseCmd::rspSignin* Arena::CreateMaybeMessage<::BaseCmd::rspSignin>(Arena*);
template<> ::BaseCmd::sUser* Arena::CreateMaybeMessage<::BaseCmd::sUser>(Arena*);
template<> ::BaseCmd::sUser_ePhoneNumber* Arena::CreateMaybeMessage<::BaseCmd::sUser_ePhoneNumber>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace BaseCmd {

enum notifyConnectionStatus_eConnectionStatus {
  notifyConnectionStatus_eConnectionStatus_ConnectSuccess = 0,
  notifyConnectionStatus_eConnectionStatus_ConnectFailed = 1,
  notifyConnectionStatus_eConnectionStatus_ConnectionLost = 2
};
bool notifyConnectionStatus_eConnectionStatus_IsValid(int value);
const notifyConnectionStatus_eConnectionStatus notifyConnectionStatus_eConnectionStatus_eConnectionStatus_MIN = notifyConnectionStatus_eConnectionStatus_ConnectSuccess;
const notifyConnectionStatus_eConnectionStatus notifyConnectionStatus_eConnectionStatus_eConnectionStatus_MAX = notifyConnectionStatus_eConnectionStatus_ConnectionLost;
const int notifyConnectionStatus_eConnectionStatus_eConnectionStatus_ARRAYSIZE = notifyConnectionStatus_eConnectionStatus_eConnectionStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* notifyConnectionStatus_eConnectionStatus_descriptor();
inline const ::std::string& notifyConnectionStatus_eConnectionStatus_Name(notifyConnectionStatus_eConnectionStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    notifyConnectionStatus_eConnectionStatus_descriptor(), value);
}
inline bool notifyConnectionStatus_eConnectionStatus_Parse(
    const ::std::string& name, notifyConnectionStatus_eConnectionStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<notifyConnectionStatus_eConnectionStatus>(
    notifyConnectionStatus_eConnectionStatus_descriptor(), name, value);
}
enum sUser_ePhoneType {
  sUser_ePhoneType_MOBILE = 0,
  sUser_ePhoneType_HOME = 1,
  sUser_ePhoneType_WORK = 2
};
bool sUser_ePhoneType_IsValid(int value);
const sUser_ePhoneType sUser_ePhoneType_ePhoneType_MIN = sUser_ePhoneType_MOBILE;
const sUser_ePhoneType sUser_ePhoneType_ePhoneType_MAX = sUser_ePhoneType_WORK;
const int sUser_ePhoneType_ePhoneType_ARRAYSIZE = sUser_ePhoneType_ePhoneType_MAX + 1;

const ::google::protobuf::EnumDescriptor* sUser_ePhoneType_descriptor();
inline const ::std::string& sUser_ePhoneType_Name(sUser_ePhoneType value) {
  return ::google::protobuf::internal::NameOfEnum(
    sUser_ePhoneType_descriptor(), value);
}
inline bool sUser_ePhoneType_Parse(
    const ::std::string& name, sUser_ePhoneType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<sUser_ePhoneType>(
    sUser_ePhoneType_descriptor(), name, value);
}
// ===================================================================

class CmdType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:BaseCmd.CmdType) */ {
 public:
  CmdType();
  virtual ~CmdType();

  CmdType(const CmdType& from);

  inline CmdType& operator=(const CmdType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CmdType(CmdType&& from) noexcept
    : CmdType() {
    *this = ::std::move(from);
  }

  inline CmdType& operator=(CmdType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CmdType* internal_default_instance() {
    return reinterpret_cast<const CmdType*>(
               &_CmdType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(CmdType* other);
  friend void swap(CmdType& a, CmdType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CmdType* New() const final {
    return CreateMaybeMessage<CmdType>(NULL);
  }

  CmdType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CmdType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CmdType& from);
  void MergeFrom(const CmdType& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CmdType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional string fromip = 3;
  bool has_fromip() const;
  void clear_fromip();
  static const int kFromipFieldNumber = 3;
  const ::std::string& fromip() const;
  void set_fromip(const ::std::string& value);
  #if LANG_CXX11
  void set_fromip(::std::string&& value);
  #endif
  void set_fromip(const char* value);
  void set_fromip(const char* value, size_t size);
  ::std::string* mutable_fromip();
  ::std::string* release_fromip();
  void set_allocated_fromip(::std::string* fromip);

  // optional string toip = 4;
  bool has_toip() const;
  void clear_toip();
  static const int kToipFieldNumber = 4;
  const ::std::string& toip() const;
  void set_toip(const ::std::string& value);
  #if LANG_CXX11
  void set_toip(::std::string&& value);
  #endif
  void set_toip(const char* value);
  void set_toip(const char* value, size_t size);
  ::std::string* mutable_toip();
  ::std::string* release_toip();
  void set_allocated_toip(::std::string* toip);

  // required int32 size = 2;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 2;
  ::google::protobuf::int32 size() const;
  void set_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BaseCmd.CmdType)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_size();
  void clear_has_size();
  void set_has_fromip();
  void clear_has_fromip();
  void set_has_toip();
  void clear_has_toip();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr fromip_;
  ::google::protobuf::internal::ArenaStringPtr toip_;
  ::google::protobuf::int32 size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class notifyConnectionStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:BaseCmd.notifyConnectionStatus) */ {
 public:
  notifyConnectionStatus();
  virtual ~notifyConnectionStatus();

  notifyConnectionStatus(const notifyConnectionStatus& from);

  inline notifyConnectionStatus& operator=(const notifyConnectionStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  notifyConnectionStatus(notifyConnectionStatus&& from) noexcept
    : notifyConnectionStatus() {
    *this = ::std::move(from);
  }

  inline notifyConnectionStatus& operator=(notifyConnectionStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const notifyConnectionStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const notifyConnectionStatus* internal_default_instance() {
    return reinterpret_cast<const notifyConnectionStatus*>(
               &_notifyConnectionStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(notifyConnectionStatus* other);
  friend void swap(notifyConnectionStatus& a, notifyConnectionStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline notifyConnectionStatus* New() const final {
    return CreateMaybeMessage<notifyConnectionStatus>(NULL);
  }

  notifyConnectionStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<notifyConnectionStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const notifyConnectionStatus& from);
  void MergeFrom(const notifyConnectionStatus& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(notifyConnectionStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef notifyConnectionStatus_eConnectionStatus eConnectionStatus;
  static const eConnectionStatus ConnectSuccess =
    notifyConnectionStatus_eConnectionStatus_ConnectSuccess;
  static const eConnectionStatus ConnectFailed =
    notifyConnectionStatus_eConnectionStatus_ConnectFailed;
  static const eConnectionStatus ConnectionLost =
    notifyConnectionStatus_eConnectionStatus_ConnectionLost;
  static inline bool eConnectionStatus_IsValid(int value) {
    return notifyConnectionStatus_eConnectionStatus_IsValid(value);
  }
  static const eConnectionStatus eConnectionStatus_MIN =
    notifyConnectionStatus_eConnectionStatus_eConnectionStatus_MIN;
  static const eConnectionStatus eConnectionStatus_MAX =
    notifyConnectionStatus_eConnectionStatus_eConnectionStatus_MAX;
  static const int eConnectionStatus_ARRAYSIZE =
    notifyConnectionStatus_eConnectionStatus_eConnectionStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  eConnectionStatus_descriptor() {
    return notifyConnectionStatus_eConnectionStatus_descriptor();
  }
  static inline const ::std::string& eConnectionStatus_Name(eConnectionStatus value) {
    return notifyConnectionStatus_eConnectionStatus_Name(value);
  }
  static inline bool eConnectionStatus_Parse(const ::std::string& name,
      eConnectionStatus* value) {
    return notifyConnectionStatus_eConnectionStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .BaseCmd.notifyConnectionStatus.eConnectionStatus status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::BaseCmd::notifyConnectionStatus_eConnectionStatus status() const;
  void set_status(::BaseCmd::notifyConnectionStatus_eConnectionStatus value);

  // @@protoc_insertion_point(class_scope:BaseCmd.notifyConnectionStatus)
 private:
  void set_has_status();
  void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int status_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class sUser_ePhoneNumber : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:BaseCmd.sUser.ePhoneNumber) */ {
 public:
  sUser_ePhoneNumber();
  virtual ~sUser_ePhoneNumber();

  sUser_ePhoneNumber(const sUser_ePhoneNumber& from);

  inline sUser_ePhoneNumber& operator=(const sUser_ePhoneNumber& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  sUser_ePhoneNumber(sUser_ePhoneNumber&& from) noexcept
    : sUser_ePhoneNumber() {
    *this = ::std::move(from);
  }

  inline sUser_ePhoneNumber& operator=(sUser_ePhoneNumber&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sUser_ePhoneNumber& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const sUser_ePhoneNumber* internal_default_instance() {
    return reinterpret_cast<const sUser_ePhoneNumber*>(
               &_sUser_ePhoneNumber_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(sUser_ePhoneNumber* other);
  friend void swap(sUser_ePhoneNumber& a, sUser_ePhoneNumber& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline sUser_ePhoneNumber* New() const final {
    return CreateMaybeMessage<sUser_ePhoneNumber>(NULL);
  }

  sUser_ePhoneNumber* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<sUser_ePhoneNumber>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const sUser_ePhoneNumber& from);
  void MergeFrom(const sUser_ePhoneNumber& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(sUser_ePhoneNumber* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string number = 1;
  bool has_number() const;
  void clear_number();
  static const int kNumberFieldNumber = 1;
  const ::std::string& number() const;
  void set_number(const ::std::string& value);
  #if LANG_CXX11
  void set_number(::std::string&& value);
  #endif
  void set_number(const char* value);
  void set_number(const char* value, size_t size);
  ::std::string* mutable_number();
  ::std::string* release_number();
  void set_allocated_number(::std::string* number);

  // optional .BaseCmd.sUser.ePhoneType type = 2 [default = HOME];
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::BaseCmd::sUser_ePhoneType type() const;
  void set_type(::BaseCmd::sUser_ePhoneType value);

  // @@protoc_insertion_point(class_scope:BaseCmd.sUser.ePhoneNumber)
 private:
  void set_has_number();
  void clear_has_number();
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr number_;
  int type_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class sUser : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:BaseCmd.sUser) */ {
 public:
  sUser();
  virtual ~sUser();

  sUser(const sUser& from);

  inline sUser& operator=(const sUser& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  sUser(sUser&& from) noexcept
    : sUser() {
    *this = ::std::move(from);
  }

  inline sUser& operator=(sUser&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sUser& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const sUser* internal_default_instance() {
    return reinterpret_cast<const sUser*>(
               &_sUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(sUser* other);
  friend void swap(sUser& a, sUser& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline sUser* New() const final {
    return CreateMaybeMessage<sUser>(NULL);
  }

  sUser* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<sUser>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const sUser& from);
  void MergeFrom(const sUser& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(sUser* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef sUser_ePhoneNumber ePhoneNumber;

  typedef sUser_ePhoneType ePhoneType;
  static const ePhoneType MOBILE =
    sUser_ePhoneType_MOBILE;
  static const ePhoneType HOME =
    sUser_ePhoneType_HOME;
  static const ePhoneType WORK =
    sUser_ePhoneType_WORK;
  static inline bool ePhoneType_IsValid(int value) {
    return sUser_ePhoneType_IsValid(value);
  }
  static const ePhoneType ePhoneType_MIN =
    sUser_ePhoneType_ePhoneType_MIN;
  static const ePhoneType ePhoneType_MAX =
    sUser_ePhoneType_ePhoneType_MAX;
  static const int ePhoneType_ARRAYSIZE =
    sUser_ePhoneType_ePhoneType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ePhoneType_descriptor() {
    return sUser_ePhoneType_descriptor();
  }
  static inline const ::std::string& ePhoneType_Name(ePhoneType value) {
    return sUser_ePhoneType_Name(value);
  }
  static inline bool ePhoneType_Parse(const ::std::string& name,
      ePhoneType* value) {
    return sUser_ePhoneType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .BaseCmd.sUser.ePhoneNumber phones = 4;
  int phones_size() const;
  void clear_phones();
  static const int kPhonesFieldNumber = 4;
  ::BaseCmd::sUser_ePhoneNumber* mutable_phones(int index);
  ::google::protobuf::RepeatedPtrField< ::BaseCmd::sUser_ePhoneNumber >*
      mutable_phones();
  const ::BaseCmd::sUser_ePhoneNumber& phones(int index) const;
  ::BaseCmd::sUser_ePhoneNumber* add_phones();
  const ::google::protobuf::RepeatedPtrField< ::BaseCmd::sUser_ePhoneNumber >&
      phones() const;

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string email = 3;
  bool has_email() const;
  void clear_email();
  static const int kEmailFieldNumber = 3;
  const ::std::string& email() const;
  void set_email(const ::std::string& value);
  #if LANG_CXX11
  void set_email(::std::string&& value);
  #endif
  void set_email(const char* value);
  void set_email(const char* value, size_t size);
  ::std::string* mutable_email();
  ::std::string* release_email();
  void set_allocated_email(::std::string* email);

  // required int32 id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BaseCmd.sUser)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_id();
  void clear_has_id();
  void set_has_email();
  void clear_has_email();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::BaseCmd::sUser_ePhoneNumber > phones_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr email_;
  ::google::protobuf::int32 id_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class reqSignin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:BaseCmd.reqSignin) */ {
 public:
  reqSignin();
  virtual ~reqSignin();

  reqSignin(const reqSignin& from);

  inline reqSignin& operator=(const reqSignin& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  reqSignin(reqSignin&& from) noexcept
    : reqSignin() {
    *this = ::std::move(from);
  }

  inline reqSignin& operator=(reqSignin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const reqSignin& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const reqSignin* internal_default_instance() {
    return reinterpret_cast<const reqSignin*>(
               &_reqSignin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(reqSignin* other);
  friend void swap(reqSignin& a, reqSignin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline reqSignin* New() const final {
    return CreateMaybeMessage<reqSignin>(NULL);
  }

  reqSignin* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<reqSignin>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const reqSignin& from);
  void MergeFrom(const reqSignin& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(reqSignin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .BaseCmd.sUser user = 1;
  int user_size() const;
  void clear_user();
  static const int kUserFieldNumber = 1;
  ::BaseCmd::sUser* mutable_user(int index);
  ::google::protobuf::RepeatedPtrField< ::BaseCmd::sUser >*
      mutable_user();
  const ::BaseCmd::sUser& user(int index) const;
  ::BaseCmd::sUser* add_user();
  const ::google::protobuf::RepeatedPtrField< ::BaseCmd::sUser >&
      user() const;

  // @@protoc_insertion_point(class_scope:BaseCmd.reqSignin)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::BaseCmd::sUser > user_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class rspSignin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:BaseCmd.rspSignin) */ {
 public:
  rspSignin();
  virtual ~rspSignin();

  rspSignin(const rspSignin& from);

  inline rspSignin& operator=(const rspSignin& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  rspSignin(rspSignin&& from) noexcept
    : rspSignin() {
    *this = ::std::move(from);
  }

  inline rspSignin& operator=(rspSignin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const rspSignin& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const rspSignin* internal_default_instance() {
    return reinterpret_cast<const rspSignin*>(
               &_rspSignin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(rspSignin* other);
  friend void swap(rspSignin& a, rspSignin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline rspSignin* New() const final {
    return CreateMaybeMessage<rspSignin>(NULL);
  }

  rspSignin* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<rspSignin>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const rspSignin& from);
  void MergeFrom(const rspSignin& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(rspSignin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required bool succ = 2;
  bool has_succ() const;
  void clear_succ();
  static const int kSuccFieldNumber = 2;
  bool succ() const;
  void set_succ(bool value);

  // @@protoc_insertion_point(class_scope:BaseCmd.rspSignin)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_succ();
  void clear_has_succ();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  bool succ_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class reqMove : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:BaseCmd.reqMove) */ {
 public:
  reqMove();
  virtual ~reqMove();

  reqMove(const reqMove& from);

  inline reqMove& operator=(const reqMove& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  reqMove(reqMove&& from) noexcept
    : reqMove() {
    *this = ::std::move(from);
  }

  inline reqMove& operator=(reqMove&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const reqMove& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const reqMove* internal_default_instance() {
    return reinterpret_cast<const reqMove*>(
               &_reqMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(reqMove* other);
  friend void swap(reqMove& a, reqMove& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline reqMove* New() const final {
    return CreateMaybeMessage<reqMove>(NULL);
  }

  reqMove* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<reqMove>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const reqMove& from);
  void MergeFrom(const reqMove& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(reqMove* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float forward = 1;
  bool has_forward() const;
  void clear_forward();
  static const int kForwardFieldNumber = 1;
  float forward() const;
  void set_forward(float value);

  // required float angle = 2;
  bool has_angle() const;
  void clear_angle();
  static const int kAngleFieldNumber = 2;
  float angle() const;
  void set_angle(float value);

  // @@protoc_insertion_point(class_scope:BaseCmd.reqMove)
 private:
  void set_has_forward();
  void clear_has_forward();
  void set_has_angle();
  void clear_has_angle();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float forward_;
  float angle_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class rspMove : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:BaseCmd.rspMove) */ {
 public:
  rspMove();
  virtual ~rspMove();

  rspMove(const rspMove& from);

  inline rspMove& operator=(const rspMove& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  rspMove(rspMove&& from) noexcept
    : rspMove() {
    *this = ::std::move(from);
  }

  inline rspMove& operator=(rspMove&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const rspMove& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const rspMove* internal_default_instance() {
    return reinterpret_cast<const rspMove*>(
               &_rspMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(rspMove* other);
  friend void swap(rspMove& a, rspMove& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline rspMove* New() const final {
    return CreateMaybeMessage<rspMove>(NULL);
  }

  rspMove* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<rspMove>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const rspMove& from);
  void MergeFrom(const rspMove& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(rspMove* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // @@protoc_insertion_point(class_scope:BaseCmd.rspMove)
 private:
  void set_has_error();
  void clear_has_error();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class reqAlarm : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:BaseCmd.reqAlarm) */ {
 public:
  reqAlarm();
  virtual ~reqAlarm();

  reqAlarm(const reqAlarm& from);

  inline reqAlarm& operator=(const reqAlarm& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  reqAlarm(reqAlarm&& from) noexcept
    : reqAlarm() {
    *this = ::std::move(from);
  }

  inline reqAlarm& operator=(reqAlarm&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const reqAlarm& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const reqAlarm* internal_default_instance() {
    return reinterpret_cast<const reqAlarm*>(
               &_reqAlarm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(reqAlarm* other);
  friend void swap(reqAlarm& a, reqAlarm& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline reqAlarm* New() const final {
    return CreateMaybeMessage<reqAlarm>(NULL);
  }

  reqAlarm* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<reqAlarm>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const reqAlarm& from);
  void MergeFrom(const reqAlarm& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(reqAlarm* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string infomessage = 1;
  bool has_infomessage() const;
  void clear_infomessage();
  static const int kInfomessageFieldNumber = 1;
  const ::std::string& infomessage() const;
  void set_infomessage(const ::std::string& value);
  #if LANG_CXX11
  void set_infomessage(::std::string&& value);
  #endif
  void set_infomessage(const char* value);
  void set_infomessage(const char* value, size_t size);
  ::std::string* mutable_infomessage();
  ::std::string* release_infomessage();
  void set_allocated_infomessage(::std::string* infomessage);

  // @@protoc_insertion_point(class_scope:BaseCmd.reqAlarm)
 private:
  void set_has_infomessage();
  void clear_has_infomessage();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr infomessage_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class rspAlarm : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:BaseCmd.rspAlarm) */ {
 public:
  rspAlarm();
  virtual ~rspAlarm();

  rspAlarm(const rspAlarm& from);

  inline rspAlarm& operator=(const rspAlarm& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  rspAlarm(rspAlarm&& from) noexcept
    : rspAlarm() {
    *this = ::std::move(from);
  }

  inline rspAlarm& operator=(rspAlarm&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const rspAlarm& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const rspAlarm* internal_default_instance() {
    return reinterpret_cast<const rspAlarm*>(
               &_rspAlarm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(rspAlarm* other);
  friend void swap(rspAlarm& a, rspAlarm& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline rspAlarm* New() const final {
    return CreateMaybeMessage<rspAlarm>(NULL);
  }

  rspAlarm* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<rspAlarm>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const rspAlarm& from);
  void MergeFrom(const rspAlarm& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(rspAlarm* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // @@protoc_insertion_point(class_scope:BaseCmd.rspAlarm)
 private:
  void set_has_error();
  void clear_has_error();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CmdType

// required string type = 1;
inline bool CmdType::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CmdType::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CmdType::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CmdType::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& CmdType::type() const {
  // @@protoc_insertion_point(field_get:BaseCmd.CmdType.type)
  return type_.GetNoArena();
}
inline void CmdType::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:BaseCmd.CmdType.type)
}
#if LANG_CXX11
inline void CmdType::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:BaseCmd.CmdType.type)
}
#endif
inline void CmdType::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:BaseCmd.CmdType.type)
}
inline void CmdType::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:BaseCmd.CmdType.type)
}
inline ::std::string* CmdType::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:BaseCmd.CmdType.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CmdType::release_type() {
  // @@protoc_insertion_point(field_release:BaseCmd.CmdType.type)
  if (!has_type()) {
    return NULL;
  }
  clear_has_type();
  return type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CmdType::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:BaseCmd.CmdType.type)
}

// required int32 size = 2;
inline bool CmdType::has_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CmdType::set_has_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CmdType::clear_has_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CmdType::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 CmdType::size() const {
  // @@protoc_insertion_point(field_get:BaseCmd.CmdType.size)
  return size_;
}
inline void CmdType::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:BaseCmd.CmdType.size)
}

// optional string fromip = 3;
inline bool CmdType::has_fromip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CmdType::set_has_fromip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CmdType::clear_has_fromip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CmdType::clear_fromip() {
  fromip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fromip();
}
inline const ::std::string& CmdType::fromip() const {
  // @@protoc_insertion_point(field_get:BaseCmd.CmdType.fromip)
  return fromip_.GetNoArena();
}
inline void CmdType::set_fromip(const ::std::string& value) {
  set_has_fromip();
  fromip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:BaseCmd.CmdType.fromip)
}
#if LANG_CXX11
inline void CmdType::set_fromip(::std::string&& value) {
  set_has_fromip();
  fromip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:BaseCmd.CmdType.fromip)
}
#endif
inline void CmdType::set_fromip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_fromip();
  fromip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:BaseCmd.CmdType.fromip)
}
inline void CmdType::set_fromip(const char* value, size_t size) {
  set_has_fromip();
  fromip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:BaseCmd.CmdType.fromip)
}
inline ::std::string* CmdType::mutable_fromip() {
  set_has_fromip();
  // @@protoc_insertion_point(field_mutable:BaseCmd.CmdType.fromip)
  return fromip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CmdType::release_fromip() {
  // @@protoc_insertion_point(field_release:BaseCmd.CmdType.fromip)
  if (!has_fromip()) {
    return NULL;
  }
  clear_has_fromip();
  return fromip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CmdType::set_allocated_fromip(::std::string* fromip) {
  if (fromip != NULL) {
    set_has_fromip();
  } else {
    clear_has_fromip();
  }
  fromip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fromip);
  // @@protoc_insertion_point(field_set_allocated:BaseCmd.CmdType.fromip)
}

// optional string toip = 4;
inline bool CmdType::has_toip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CmdType::set_has_toip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CmdType::clear_has_toip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CmdType::clear_toip() {
  toip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_toip();
}
inline const ::std::string& CmdType::toip() const {
  // @@protoc_insertion_point(field_get:BaseCmd.CmdType.toip)
  return toip_.GetNoArena();
}
inline void CmdType::set_toip(const ::std::string& value) {
  set_has_toip();
  toip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:BaseCmd.CmdType.toip)
}
#if LANG_CXX11
inline void CmdType::set_toip(::std::string&& value) {
  set_has_toip();
  toip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:BaseCmd.CmdType.toip)
}
#endif
inline void CmdType::set_toip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_toip();
  toip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:BaseCmd.CmdType.toip)
}
inline void CmdType::set_toip(const char* value, size_t size) {
  set_has_toip();
  toip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:BaseCmd.CmdType.toip)
}
inline ::std::string* CmdType::mutable_toip() {
  set_has_toip();
  // @@protoc_insertion_point(field_mutable:BaseCmd.CmdType.toip)
  return toip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CmdType::release_toip() {
  // @@protoc_insertion_point(field_release:BaseCmd.CmdType.toip)
  if (!has_toip()) {
    return NULL;
  }
  clear_has_toip();
  return toip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CmdType::set_allocated_toip(::std::string* toip) {
  if (toip != NULL) {
    set_has_toip();
  } else {
    clear_has_toip();
  }
  toip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), toip);
  // @@protoc_insertion_point(field_set_allocated:BaseCmd.CmdType.toip)
}

// -------------------------------------------------------------------

// notifyConnectionStatus

// required .BaseCmd.notifyConnectionStatus.eConnectionStatus status = 1;
inline bool notifyConnectionStatus::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void notifyConnectionStatus::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void notifyConnectionStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void notifyConnectionStatus::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::BaseCmd::notifyConnectionStatus_eConnectionStatus notifyConnectionStatus::status() const {
  // @@protoc_insertion_point(field_get:BaseCmd.notifyConnectionStatus.status)
  return static_cast< ::BaseCmd::notifyConnectionStatus_eConnectionStatus >(status_);
}
inline void notifyConnectionStatus::set_status(::BaseCmd::notifyConnectionStatus_eConnectionStatus value) {
  assert(::BaseCmd::notifyConnectionStatus_eConnectionStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:BaseCmd.notifyConnectionStatus.status)
}

// -------------------------------------------------------------------

// sUser_ePhoneNumber

// required string number = 1;
inline bool sUser_ePhoneNumber::has_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sUser_ePhoneNumber::set_has_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sUser_ePhoneNumber::clear_has_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sUser_ePhoneNumber::clear_number() {
  number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_number();
}
inline const ::std::string& sUser_ePhoneNumber::number() const {
  // @@protoc_insertion_point(field_get:BaseCmd.sUser.ePhoneNumber.number)
  return number_.GetNoArena();
}
inline void sUser_ePhoneNumber::set_number(const ::std::string& value) {
  set_has_number();
  number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:BaseCmd.sUser.ePhoneNumber.number)
}
#if LANG_CXX11
inline void sUser_ePhoneNumber::set_number(::std::string&& value) {
  set_has_number();
  number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:BaseCmd.sUser.ePhoneNumber.number)
}
#endif
inline void sUser_ePhoneNumber::set_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_number();
  number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:BaseCmd.sUser.ePhoneNumber.number)
}
inline void sUser_ePhoneNumber::set_number(const char* value, size_t size) {
  set_has_number();
  number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:BaseCmd.sUser.ePhoneNumber.number)
}
inline ::std::string* sUser_ePhoneNumber::mutable_number() {
  set_has_number();
  // @@protoc_insertion_point(field_mutable:BaseCmd.sUser.ePhoneNumber.number)
  return number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* sUser_ePhoneNumber::release_number() {
  // @@protoc_insertion_point(field_release:BaseCmd.sUser.ePhoneNumber.number)
  if (!has_number()) {
    return NULL;
  }
  clear_has_number();
  return number_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void sUser_ePhoneNumber::set_allocated_number(::std::string* number) {
  if (number != NULL) {
    set_has_number();
  } else {
    clear_has_number();
  }
  number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), number);
  // @@protoc_insertion_point(field_set_allocated:BaseCmd.sUser.ePhoneNumber.number)
}

// optional .BaseCmd.sUser.ePhoneType type = 2 [default = HOME];
inline bool sUser_ePhoneNumber::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void sUser_ePhoneNumber::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void sUser_ePhoneNumber::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void sUser_ePhoneNumber::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::BaseCmd::sUser_ePhoneType sUser_ePhoneNumber::type() const {
  // @@protoc_insertion_point(field_get:BaseCmd.sUser.ePhoneNumber.type)
  return static_cast< ::BaseCmd::sUser_ePhoneType >(type_);
}
inline void sUser_ePhoneNumber::set_type(::BaseCmd::sUser_ePhoneType value) {
  assert(::BaseCmd::sUser_ePhoneType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:BaseCmd.sUser.ePhoneNumber.type)
}

// -------------------------------------------------------------------

// sUser

// required string name = 1;
inline bool sUser::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sUser::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sUser::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sUser::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& sUser::name() const {
  // @@protoc_insertion_point(field_get:BaseCmd.sUser.name)
  return name_.GetNoArena();
}
inline void sUser::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:BaseCmd.sUser.name)
}
#if LANG_CXX11
inline void sUser::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:BaseCmd.sUser.name)
}
#endif
inline void sUser::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:BaseCmd.sUser.name)
}
inline void sUser::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:BaseCmd.sUser.name)
}
inline ::std::string* sUser::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:BaseCmd.sUser.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* sUser::release_name() {
  // @@protoc_insertion_point(field_release:BaseCmd.sUser.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void sUser::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:BaseCmd.sUser.name)
}

// required int32 id = 2;
inline bool sUser::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void sUser::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void sUser::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void sUser::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 sUser::id() const {
  // @@protoc_insertion_point(field_get:BaseCmd.sUser.id)
  return id_;
}
inline void sUser::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:BaseCmd.sUser.id)
}

// optional string email = 3;
inline bool sUser::has_email() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void sUser::set_has_email() {
  _has_bits_[0] |= 0x00000002u;
}
inline void sUser::clear_has_email() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void sUser::clear_email() {
  email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_email();
}
inline const ::std::string& sUser::email() const {
  // @@protoc_insertion_point(field_get:BaseCmd.sUser.email)
  return email_.GetNoArena();
}
inline void sUser::set_email(const ::std::string& value) {
  set_has_email();
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:BaseCmd.sUser.email)
}
#if LANG_CXX11
inline void sUser::set_email(::std::string&& value) {
  set_has_email();
  email_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:BaseCmd.sUser.email)
}
#endif
inline void sUser::set_email(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_email();
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:BaseCmd.sUser.email)
}
inline void sUser::set_email(const char* value, size_t size) {
  set_has_email();
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:BaseCmd.sUser.email)
}
inline ::std::string* sUser::mutable_email() {
  set_has_email();
  // @@protoc_insertion_point(field_mutable:BaseCmd.sUser.email)
  return email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* sUser::release_email() {
  // @@protoc_insertion_point(field_release:BaseCmd.sUser.email)
  if (!has_email()) {
    return NULL;
  }
  clear_has_email();
  return email_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void sUser::set_allocated_email(::std::string* email) {
  if (email != NULL) {
    set_has_email();
  } else {
    clear_has_email();
  }
  email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), email);
  // @@protoc_insertion_point(field_set_allocated:BaseCmd.sUser.email)
}

// repeated .BaseCmd.sUser.ePhoneNumber phones = 4;
inline int sUser::phones_size() const {
  return phones_.size();
}
inline void sUser::clear_phones() {
  phones_.Clear();
}
inline ::BaseCmd::sUser_ePhoneNumber* sUser::mutable_phones(int index) {
  // @@protoc_insertion_point(field_mutable:BaseCmd.sUser.phones)
  return phones_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::BaseCmd::sUser_ePhoneNumber >*
sUser::mutable_phones() {
  // @@protoc_insertion_point(field_mutable_list:BaseCmd.sUser.phones)
  return &phones_;
}
inline const ::BaseCmd::sUser_ePhoneNumber& sUser::phones(int index) const {
  // @@protoc_insertion_point(field_get:BaseCmd.sUser.phones)
  return phones_.Get(index);
}
inline ::BaseCmd::sUser_ePhoneNumber* sUser::add_phones() {
  // @@protoc_insertion_point(field_add:BaseCmd.sUser.phones)
  return phones_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BaseCmd::sUser_ePhoneNumber >&
sUser::phones() const {
  // @@protoc_insertion_point(field_list:BaseCmd.sUser.phones)
  return phones_;
}

// -------------------------------------------------------------------

// reqSignin

// repeated .BaseCmd.sUser user = 1;
inline int reqSignin::user_size() const {
  return user_.size();
}
inline void reqSignin::clear_user() {
  user_.Clear();
}
inline ::BaseCmd::sUser* reqSignin::mutable_user(int index) {
  // @@protoc_insertion_point(field_mutable:BaseCmd.reqSignin.user)
  return user_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::BaseCmd::sUser >*
reqSignin::mutable_user() {
  // @@protoc_insertion_point(field_mutable_list:BaseCmd.reqSignin.user)
  return &user_;
}
inline const ::BaseCmd::sUser& reqSignin::user(int index) const {
  // @@protoc_insertion_point(field_get:BaseCmd.reqSignin.user)
  return user_.Get(index);
}
inline ::BaseCmd::sUser* reqSignin::add_user() {
  // @@protoc_insertion_point(field_add:BaseCmd.reqSignin.user)
  return user_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BaseCmd::sUser >&
reqSignin::user() const {
  // @@protoc_insertion_point(field_list:BaseCmd.reqSignin.user)
  return user_;
}

// -------------------------------------------------------------------

// rspSignin

// required string name = 1;
inline bool rspSignin::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void rspSignin::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void rspSignin::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void rspSignin::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& rspSignin::name() const {
  // @@protoc_insertion_point(field_get:BaseCmd.rspSignin.name)
  return name_.GetNoArena();
}
inline void rspSignin::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:BaseCmd.rspSignin.name)
}
#if LANG_CXX11
inline void rspSignin::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:BaseCmd.rspSignin.name)
}
#endif
inline void rspSignin::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:BaseCmd.rspSignin.name)
}
inline void rspSignin::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:BaseCmd.rspSignin.name)
}
inline ::std::string* rspSignin::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:BaseCmd.rspSignin.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* rspSignin::release_name() {
  // @@protoc_insertion_point(field_release:BaseCmd.rspSignin.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void rspSignin::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:BaseCmd.rspSignin.name)
}

// required bool succ = 2;
inline bool rspSignin::has_succ() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void rspSignin::set_has_succ() {
  _has_bits_[0] |= 0x00000002u;
}
inline void rspSignin::clear_has_succ() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void rspSignin::clear_succ() {
  succ_ = false;
  clear_has_succ();
}
inline bool rspSignin::succ() const {
  // @@protoc_insertion_point(field_get:BaseCmd.rspSignin.succ)
  return succ_;
}
inline void rspSignin::set_succ(bool value) {
  set_has_succ();
  succ_ = value;
  // @@protoc_insertion_point(field_set:BaseCmd.rspSignin.succ)
}

// -------------------------------------------------------------------

// reqMove

// required float forward = 1;
inline bool reqMove::has_forward() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void reqMove::set_has_forward() {
  _has_bits_[0] |= 0x00000001u;
}
inline void reqMove::clear_has_forward() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void reqMove::clear_forward() {
  forward_ = 0;
  clear_has_forward();
}
inline float reqMove::forward() const {
  // @@protoc_insertion_point(field_get:BaseCmd.reqMove.forward)
  return forward_;
}
inline void reqMove::set_forward(float value) {
  set_has_forward();
  forward_ = value;
  // @@protoc_insertion_point(field_set:BaseCmd.reqMove.forward)
}

// required float angle = 2;
inline bool reqMove::has_angle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void reqMove::set_has_angle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void reqMove::clear_has_angle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void reqMove::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline float reqMove::angle() const {
  // @@protoc_insertion_point(field_get:BaseCmd.reqMove.angle)
  return angle_;
}
inline void reqMove::set_angle(float value) {
  set_has_angle();
  angle_ = value;
  // @@protoc_insertion_point(field_set:BaseCmd.reqMove.angle)
}

// -------------------------------------------------------------------

// rspMove

// required string error = 1;
inline bool rspMove::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void rspMove::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void rspMove::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void rspMove::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error();
}
inline const ::std::string& rspMove::error() const {
  // @@protoc_insertion_point(field_get:BaseCmd.rspMove.error)
  return error_.GetNoArena();
}
inline void rspMove::set_error(const ::std::string& value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:BaseCmd.rspMove.error)
}
#if LANG_CXX11
inline void rspMove::set_error(::std::string&& value) {
  set_has_error();
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:BaseCmd.rspMove.error)
}
#endif
inline void rspMove::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:BaseCmd.rspMove.error)
}
inline void rspMove::set_error(const char* value, size_t size) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:BaseCmd.rspMove.error)
}
inline ::std::string* rspMove::mutable_error() {
  set_has_error();
  // @@protoc_insertion_point(field_mutable:BaseCmd.rspMove.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* rspMove::release_error() {
  // @@protoc_insertion_point(field_release:BaseCmd.rspMove.error)
  if (!has_error()) {
    return NULL;
  }
  clear_has_error();
  return error_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void rspMove::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    set_has_error();
  } else {
    clear_has_error();
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:BaseCmd.rspMove.error)
}

// -------------------------------------------------------------------

// reqAlarm

// required string infomessage = 1;
inline bool reqAlarm::has_infomessage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void reqAlarm::set_has_infomessage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void reqAlarm::clear_has_infomessage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void reqAlarm::clear_infomessage() {
  infomessage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_infomessage();
}
inline const ::std::string& reqAlarm::infomessage() const {
  // @@protoc_insertion_point(field_get:BaseCmd.reqAlarm.infomessage)
  return infomessage_.GetNoArena();
}
inline void reqAlarm::set_infomessage(const ::std::string& value) {
  set_has_infomessage();
  infomessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:BaseCmd.reqAlarm.infomessage)
}
#if LANG_CXX11
inline void reqAlarm::set_infomessage(::std::string&& value) {
  set_has_infomessage();
  infomessage_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:BaseCmd.reqAlarm.infomessage)
}
#endif
inline void reqAlarm::set_infomessage(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_infomessage();
  infomessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:BaseCmd.reqAlarm.infomessage)
}
inline void reqAlarm::set_infomessage(const char* value, size_t size) {
  set_has_infomessage();
  infomessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:BaseCmd.reqAlarm.infomessage)
}
inline ::std::string* reqAlarm::mutable_infomessage() {
  set_has_infomessage();
  // @@protoc_insertion_point(field_mutable:BaseCmd.reqAlarm.infomessage)
  return infomessage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* reqAlarm::release_infomessage() {
  // @@protoc_insertion_point(field_release:BaseCmd.reqAlarm.infomessage)
  if (!has_infomessage()) {
    return NULL;
  }
  clear_has_infomessage();
  return infomessage_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void reqAlarm::set_allocated_infomessage(::std::string* infomessage) {
  if (infomessage != NULL) {
    set_has_infomessage();
  } else {
    clear_has_infomessage();
  }
  infomessage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), infomessage);
  // @@protoc_insertion_point(field_set_allocated:BaseCmd.reqAlarm.infomessage)
}

// -------------------------------------------------------------------

// rspAlarm

// required string error = 1;
inline bool rspAlarm::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void rspAlarm::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void rspAlarm::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void rspAlarm::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error();
}
inline const ::std::string& rspAlarm::error() const {
  // @@protoc_insertion_point(field_get:BaseCmd.rspAlarm.error)
  return error_.GetNoArena();
}
inline void rspAlarm::set_error(const ::std::string& value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:BaseCmd.rspAlarm.error)
}
#if LANG_CXX11
inline void rspAlarm::set_error(::std::string&& value) {
  set_has_error();
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:BaseCmd.rspAlarm.error)
}
#endif
inline void rspAlarm::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:BaseCmd.rspAlarm.error)
}
inline void rspAlarm::set_error(const char* value, size_t size) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:BaseCmd.rspAlarm.error)
}
inline ::std::string* rspAlarm::mutable_error() {
  set_has_error();
  // @@protoc_insertion_point(field_mutable:BaseCmd.rspAlarm.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* rspAlarm::release_error() {
  // @@protoc_insertion_point(field_release:BaseCmd.rspAlarm.error)
  if (!has_error()) {
    return NULL;
  }
  clear_has_error();
  return error_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void rspAlarm::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    set_has_error();
  } else {
    clear_has_error();
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:BaseCmd.rspAlarm.error)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace BaseCmd

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::BaseCmd::notifyConnectionStatus_eConnectionStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::BaseCmd::notifyConnectionStatus_eConnectionStatus>() {
  return ::BaseCmd::notifyConnectionStatus_eConnectionStatus_descriptor();
}
template <> struct is_proto_enum< ::BaseCmd::sUser_ePhoneType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::BaseCmd::sUser_ePhoneType>() {
  return ::BaseCmd::sUser_ePhoneType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_BaseCmd_2eproto
